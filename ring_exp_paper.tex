\documentclass{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[style=lncs]{biblatex}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{layouts}
\usepackage{makecell}
\usepackage[caption=false]{subfig}
\usepackage{xcolor}
\usepackage{xspace}

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}

\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.4, 0.4, 0.4}    % grey
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green

\renewcommand\UrlFont{\color{blue}\rmfamily}

\title{A Lean tactic for normalising ring\\ expressions with exponents (short paper)}
\titlerunning{A Lean tactic for normalising ring expressions with exponents}
\author{Anne Baanen}
\authorrunning{T. Baanen}
\institute{Vrije Universiteit Amsterdam, Amsterdam, The Netherlands\\\email{t.baanen@vu.nl}}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\lean}[1]{\texttt{#1}\xspace} % for writing Lean expressions
\newcommand{\ex}{\lean{ex}}
\newcommand{\mathlib}{\texttt{mathlib}\xspace}
\newcommand{\pow}{{${}^\wedge$}\xspace}
\newcommand{\ring}{\lean{ring}}
\newcommand{\ringexp}{\lean{ring\_exp}}
\newcommand{\todo}[1]{{\color{red} TODO: #1}}

\addbibresource{lean.bib}

\begin{document}
\maketitle

\begin{abstract}
This paper describes the design of the normalising tactic \ringexp for the Lean prover.
This tactic improves on existing tactics by adding a binary exponent operator to the language of rings.
A normal form is represented with an inductive family of types, enforcing various invariants.
The design can also be extended with more operators.
\end{abstract}

\section{Introduction}

In interactive theorem proving, normalising tactics are powerful tools to prove equalities.
Given an expression $a$, these tactics return an expression $a'$ in normal form together with a proof that $a = a'$.
%Such tactics are metaprograms which can be applied to an expression $a$,
%and return an expression $a'$ in normal form, together with a proof term showing $a = a'$;
%to prove $a = b$ it suffices to normalise $a'$ and $b'$ and show $a' = b'$.
For instance, in \mathlib, the mathematical library for the Lean theorem prover~\cite{lean-prover},
%several normalising tactics are included~\cite{mathlib}.
%Among others,
%\lean{norm\_cast} normalises type coercions in an expression,
%\lean{abel} normalises expressions in an Abelian group,
the \lean{ring} tactic normalises % polynomials, i.e.
expressions in a commutative (semi)ring~\cite{mathlib}.
The \ring tactic can be directly invoked by the user
and is called by the decision procedure \lean{linarith}.
In \mathlib, \ring is invoked over 300 times, demonstrating its utility.

The \lean{ring} tactic in Lean, and the tactic in Coq it is based on,
use a Horner normal form representation of polynomials~\cite{ring-tactic}.
%The Horner normal form for univariate polynomials over $\Q$ can be given as an inductive datatype \lean{horner} with two constructors \lean{const} and \lean{xadd};
%$\lean{const}\ c$ for $c : \Q$ represents a constant polynomial $f(x) = c$,
%and $\lean{xadd}\ g\ c$ for $g : \lean{horner}, c : \Q$ represents the polynomial $f(x) = g(x) * x + c$.
The Horner form represents a polynomial $f$ with one of two cases:
either it is constant ($f(x) = c$), or it is of the form $f(x) = g(x) * x + c$.
This representation
% generalised to multivariate polynomials over arbitrary (semi)rings
allows \lean{ring} to uniquely and efficiently represent any polynomial,
i.e. any expression consisting of the operators $+$ and $*$, rational numerals and variables.
Problems arise when expressions include other operators than $+$ and $*$, such as the exponentiation operator \pow.
% such as the expression $2^n - 1$ representing an arbitrary Mersenne number.
% The exponent operator \pow can be converted to a repeated multiplication only when it is applied to a numeric exponent.
% When the exponent is itself a compound expression,
% A fundamental assumption is that the degree of each term is a constant integer,
The Horner form fundamentally assumes the degree of a term is a constant integer,
so it cannot be simply modified to represent variable exponents,
or more generally to represent \pow applied to compound expressions.
The result is that \ring cannot prove that $2^{n+1} - 1 = 2 * 2^n - 1$ for a free variable $n : \mathbb{N}$.

% Exponents also result in heterogeneous expressions: $a^b$ has $a : α$ for any ring, but $b : ℕ$.

The \ringexp tactic is a new normalisation tactic whose domain is a strict superset of \lean{ring}'s,
making it a drop-in replacement. % that can additionally solve goals such as $2^{n+1} - 1 = 2 * 2^n - 1$.
In particular, \ringexp supports the operators $+$, $*$ and \pow, rational numerals and variables,
and does so without sacrificing too much of the efficiency of \lean{ring}.
This paper describes the design and engineering challenges encountered in implementing \ringexp.
The paper discusses the version of \ringexp merged into \mathlib as of commit \texttt{5c09372658}.\footnote{Available at \url{https://github.com/leanprover-community/mathlib/tree/5c09372658}}.
Additional code and setup instructions are available online.\footnote{\url{https://github.com/lean-forward/ring_exp}}

\section{Design}

The \ringexp tactic uses a similar normalisation scheme to the original \ring tactic.
The input from the tactic system is an abstract syntax tree representing the expression to normalise.
% Lean makes the syntax available for metaprogramming as terms of type \lean{expr}.
An \lean{eval} function maps inputs to a type \lean{ex} of normalised expressions.
The normal form should be designed in such a way that values of type \lean{ex} are equal
if and only if the input expressions can be proved equal using the axioms of semirings.
From the \lean{ex} representation, the normalised output expression is constructed by the \lean{simple} function.
Both \lean{eval} and \lean{simple} additionally return a proof showing the input and output expressions are equal.
The \ringexp tactic does not use reflection but directly constructs proof terms, as is typical for tactics in \mathlib~\cite{mathlib}.
%The `ex` representation is also used by an additional tactic `ring_exp_eq` to test expressions for equality.

The language of (semi)rings implemented by \ring, with binary operators $+$, $*$ and optionally $-$ and $/$,
is extended in \ringexp with a binary exponentiation operator \pow.
The input expression can consist of these operators applied to other expressions,
with two base cases: rational numerals such as $0$, $37$ and $\frac{2}{3}$ and \emph{atoms}.
An atom is any expression which is not of the above form, e.g. a variable name $x$ or a function application $\sin (x - 2)$,
and is treated as an opaque variable in the expression.
Two such expressions are considered equal if they evaluate to equal values for any assignment to the atoms, for all commutative rings.
% The theory should not be confused with that of `exponential rings', which extends $+$ and $*$ with a unary operator $E$. %, which is a ring $(R, +, *)$ equipped with a unary operator $E$ which is a monoid homomorphism $(R, +) \to (R^*, *)$.

%For instance, each expression in the language of monoids (with associative operator $*$ and neutral element $1$) has a list of atoms as normal form;
%the conversion interprets $*$ as list concatenation `++` and $1$ as the empty list `nil`.
%Adding an associative, distributive $+$ operator will give the language of semirings,
%and by distributivity, we can always rewrite in such a way that the arguments to $*$ are not sums.
%This allows us to write a polynomial as a sum of monomials, which are themselves products of atoms.
%The exponentation operator, however, does not have such nice associativity or distributivity properties:
%in general, only `(a ^ b)^c = a ^ (b * c)` and `(a * b)^c = a^c * b^c` hold.

Using a suitable representation of the normal form is crucial to easily guarantee correctness of the normaliser.
%For expressions in the language of rings, i.e. polynomials,
%there are various possible representations with their own strengths.
%Apart from the Horner form used in the \ring tactic,
%the Lean mathematical library contains the type \lean{mv\_polynomial} representing multivariate polynomials
%as a map from monomials to coefficients, where monomials themselves are maps from the variables to their exponent, as a natural number.
%Neither representation can be easily extended with new operators,
%so \ringexp introduces its own representation of expressions named \ex. 
The \ex normal form used by \ringexp is a tree with operators at the nodes and atoms at the leaves,
but prohibits classes of non-normalised expressions by restricting which subnode can occur for each node.
% Compared with the abstract syntax tree, this will prohibit certain non-normalised subexpressions.
%For example, associativity allows rewriting $(a * b) * c$ to $a * (b * c)$ and distributivity allows rewriting $(a + b) * c$ to $(a * c) + (b * c)$,
%which leads to the rule that the left argument to $*$ cannot be of the form $a + b$ or $a * b$.
The \ex type captures these restrictions through a parameter in the enum \lean{ex\_type},
creating an inductive familty of types.
Each constructor allows specific members of the \ex family in its arguments
and returns a specific type of \ex:
\begin{lstlisting}
inductive ex : ex_type → Type
| zero  : ex_info →                     ex sum     -- 0
| sum   : ex_info → ex prod →  ex sum → ex sum     -- +
| coeff : ex_info →             coeff → ex prod
| prod  : ex_info → ex exp  → ex prod → ex prod    -- *
| exp   : ex_info → ex base → ex prod → ex exp     -- ^
| var   : ex_info →              atom → ex base
| sum_b : ex_info →            ex sum → ex base
\end{lstlisting}
%Here, the `sum` constructor represents $+$, `prod` represents $*$ and `exp` represents $\^$,
%the `zero` and `coeff` constructors represent zero and non-zero numeric coefficients,
%the `var` constructor represents an atom and
The \lean{sum\_b} constructor allows sums as the base of a power, analogously to the brackets in $(a + b) ^ c$.
An \lean{ex\_info} record stores auxiliary information used to construct correctness proofs.
For readability, we will write the representation in symbols instead of the constructors of \ex.
Thus, $n^1 * 1$ stands for \lean{prod (exp (var n) (coeff 1)) (coeff 1)} (with \lean{ex\_info} fields omitted),
in the normalised form $(2+0)^{n^1 * 1} * 1 + (-1) + 0$ of the Mersenne number $2^n - 1$.
% TODO: parallelise
% A more complicated example is that $\frac{2}{3} y^{2^k} z - x$ is represented as $x^1 * (-1) + \left(y^{(2 + 0)^{k * 1} * 1} * z^1 * \frac{2}{3} + 0\right)$.

\begin{table}
\centering
\caption{Associativity and distributivity properties of the $+$, $*$ and \pow operators.}
\def\arraystretch{1.5}%  1 is the default, change whatever you need
\label{tab:assoc-distrib}
{
\setlength{\tabcolsep}{1em} % Add horizontal padding (absolute amount)
\renewcommand{\arraystretch}{1.5}% Add vertical padding (relative amount)
\begin{tabular}{l | c c c}
	& $+$	& $*$	& \pow	\\ \hline
$+$	& $(a + b) + c = a + (b + c)$	& ---	& --- 	\\
$*$	& \makecell{$(a + b) * c = a * c + b * c$; \\ $a * (b + c) = a * b + a * c$}	& $(a * b) * c = a * (b * c) $	& --- 	\\
\pow	& $a ^ {b + c} = a ^ b + a ^ c$	& $(a * b) ^ c = a^c * b^c$	& $\left(a^b\right)^c = a^{b * c}$	\\
\end{tabular}
}
\end{table}
%Thus, the restriction that $+$ and $*$ cannot occur as the left argument to $*$,
%is reflected by the first argument to `prod` being `ex exp`, which must be of the form $a ^ b$.
%Similarly, the `sum` constructor has arguments `ex prod` and `ex sum`, reflecting that the $+$ operator is re-associated to the right in the normal form.
% Some further examples on how the equalities are reflected in the types?
The types of the arguments to each constructor are determined by the associativity and distributivity properties of the operators involved,
summarised in Table \ref{tab:assoc-distrib}.
Since addition does not distribute over either other operator (as seen from the empty entries on the $+$ row),
an expression with a sum as outermost operator cannot be rewritten so that another operator is outermost.
%The empty sum is the representation of $0$, with constructor \lean{zero}.
Thus, the set of all expressions should be represented by \lean{ex sum}.
Since $*$ distributes over $+$ but not over \pow, the next outermost operator after $+$ will be $*$.
By associativity (the diagonal entries of the table) the left argument to $+$ should have $*$ as outermost operator;
otherwise we can apply the rewrite rule $(a + b) + c \mapsto a + (b + c)$.
Analogously, the left argument to the \lean{prod} constructor is not an \lean{ex prod} but an \lean{ex exp},
% and the right argument to the \lean{exp} constructor is not an \lean{ex exp} but an \lean{ex prod}.
and the left argument to \lean{exp} is an \lean{ex base}.

%\begin{align*}
%	0 &\mapsto 0\\
%	1 &\mapsto 1 + 0\\
%	x &\mapsto x^1 * 1 + 0\\
%	\frac{2}{3} y^{2^k} z - x &\mapsto x^1 * (-1) + \left(y^{(2 + 0)^{k * 1} * 1} * z^1 * \frac{2}{3} + 0\right)
%\end{align*}

% Although the \lean{ring} tactic described by \citeauthor{ring-tactic} is based on reflection,
% kernel computation in Lean is relatively slow.
% Thus, the \ringexp tactic follows the Lean \lean{ring} tactic in constructing its proof directly.
The \lean{eval} function interprets each operator in the input expression as a corresponding operation on \ex,
building a normal form for the whole expression out of normalised subexpressions.
The operations on \ex build the correctness proof of normalisation out of the proofs for subexpressions
using a correctness lemma: for example, \lean{add\_pf\_z\_sum : ps = 0 → qs = qs' → ps + qs = qs'} constructs this proof for the input expression \lean{ps + qs} when \lean{ps} normalises to $0$.
These correctness proofs are stored in the \lean{ex\_info} record. % so they can be easily passed to other operations.

Adding support for a new operator will take relatively little work:
after extending the table of associativity and distributivity relations,
one can insert the constructor in \ex using the table to determine the relevant \lean{ex\_type}s,
and add an operation on \ex that interprets the operator.

% Finally, the \lean{tactic.interactive.ring\_exp} function ties the various parts together.
% It reads the expression(s) to normalise from the tactic state,
% parses them into an \ex,
% reads out the normalisation proofs from the \lean{ex\_info},
% and uses these proofs to rewrite the expressions.

\section{Complications} % TODO: A better word: intricacies?

The \ex type enforces that distributivity and associativity rules are always applied,
but commutative semirings have more equations.
% For instance, the $+$ and $*$ operators are also commutative:
% but this is not reflected in this definition of the \ex type:
% if $a, b : \lean{ex prod}$, $a + (b + 0)$ and $b + (a + 0)$ represent the same expression.
% $a + (b + 0)$ and $b + (a + 0)$ represent equal expressions.
In a normal form, arguments to commutative operators should be sorted according to some linear order: if $a < b$, then $a + (b + 0)$ is normalised and $b + (a + 0)$ is not.
Defining a linear order on \ex requires an order on atoms; definitional equality of atoms is tested in the \lean{tactic} monad~\cite{lean-tactics},
so a well-defined order on atoms cannot be easily expressed on the type level.
% Unfortunately, operations on expressions such as testing for definitional equality requires the usage of the \lean{tactic} monad~\cite{lean-tactics},
% making it unfeasible to enforce invariants on the type level.
% Thus, a well-defined linear order with respect to definitional equality of atoms is not expressible:
% sortedness is an invariant that cannot be checked on the type level.
Additionally, the recursive structure of expressions
means any expression $a$ can also be represented as $(a)^1*1 + 0$;
if the left argument to \pow is $0$ or $a * b + 0$, the expression is not in normal form.
These invariants which are not enforced on the type level, are instead maintained by careful programming.
A mistake in maintaining these invariants is not fatal: invariants only protect completeness, not soundness, of \ringexp.

Careful treatment of numerals in expressions is required for acceptable runtime without sacrificing completeness.
The tactic should not unfold expressions like $x * 1000$ as $1000$ additions of the variable $x$.
Representing numerals with the \lean{coeff} constructor requires an extra step to implement addition.
When terms overlap, differing only in the coefficients as for $a * b^2 * 1 + a * b^2 * 2$,
their sum is given by adding their coefficients: $a * b^2 * 3$.
Moreover, when the coefficients add up to $0$, the correct representation is not $a * b^2 * 0 : \lean{ex prod}$ but $0 : \lean{ex sum}$.
The same extra step occurs for exponents: $x ^ {a * b^2 * 1} * x ^ {a * b^2 * 2} %
% = x ^ {a * b^2 * 1 + a * b^2 * 2}
= x ^ {a * b^2 * 3}$.
Both cases are handled by a function \lean{add\_overlap} which returns the correct sum if there is overlap,
or indicates that there is no such overlap.
By choosing the order on expressions such that overlapping terms will appear adjacent in a sum,
\lean{add\_overlap} can be applied in one linear scan.

A subtle complication arises when normalising in the exponent of an expression \lean{a \pow b}:
\lean{b} is always a natural number but the type of \lean{a} is an arbitrary ring.
To correctly compute a normalised expression for \lean{b},
the tactic needs to keep track of the type of \lean{b}.
The calculations of the \lean{eval} function are thus done in an extension of the \lean{tactic} monad%~\cite{lean-tactics}
, called the \lean{ring\_exp\_m} monad.
Using a reader monad transformer~\cite{monad-transformers},
\lean{ring\_exp\_m} stores the type of the current expression
as a variable which can be swapped out when calling \lean{eval} on exponents.

Implementing subtraction and division also requires more work,
since semirings in general do not have well-defined $-$ or $/$ operators.
The tactic uses typeclass inference to determine whether the required extra structure exists on the type.
When this is the case, the operators can be rewritten:
$a - b$ becomes $a + (-1) * b$ in a ring
and $a / b$ becomes $a * b^{-1}$ in a field.

%Expressions that \ringexp cannot fully parse can still be usefully normalised:
%$(\cos x + \sin x)^2$ can still be normalised to $\cos^2 x + \sin^2 x + 2 \cos x \sin x$,
%even though $\cos$ and $\sin$ are not (yet) operators supported by \ringexp.
%Any such unparseable subexpression is considered an \emph{atom} by the tactic,
%and each atom is manipulated like a variable in a polynomial.
For completeness, atoms should be considered up to definitional equality:
\lean{($\lambda$ x, x) a} and \lean{($\lambda$ x y, x) a b} reduce to the same value \lean{a},
so % for completeness
they should be treated as the same atom.
The \lean{ring\_exp\_m} monad contains a state monad transformer to keep track of which atoms are definitionally equal.
The state consists of a list of all distinct atoms encountered in the whole input expression,
and any comparisons between atoms are instead made by comparing their indices in the list.
An additional benefit is that the indices induce an order on atoms, which is used to sort arguments to commutative operators.
% whereas Lean's built-in order can vary between executions
Within atoms, there may be subexpressions that can be normalised as well.
%For example, the argument to $\cos$.
Instead of running the normaliser directly, \ringexp calls the built-in tactic \lean{simp} with the normaliser as an argument.
The \lean{simp} tactic calls a given normaliser on each subexpression,
rewriting it when the normaliser succeeds.

\section{Optimisations}

An important practical consideration in implementing \ringexp is its efficiency, especially running time.
Among the 300 calls to \ring in \mathlib, approximately half are invocations on linear expressions by the tactic \lean{linarith}.
Since \ringexp is intended to work as a drop-in replacement for \lean{ring},
its performance characteristics, especially for linear expressions, should be comparable.

Optimising the code was a notable part of the implementation of \ringexp.
% guided by Lean's built-in profiler.
%Originally, the tactic used Lean's elaborator to fill in implicit arguments and typeclass instances when constructing terms.
%Profiling revealed that up to 90\% of running time could be spent in elaboration.
Profiling revealed that up to 90\% of running time could be spent in inferring implicit arguments and typeclass instances.
The solution was to pass all arguments explicitly and maintain a cache of typeclass instances,
also caching the expressions for the constants \lean{0} and \lean{1}.
It was possible to make these changes without large changes to the codebase,
because the required extra fields were hidden behind the \lean{ring\_exp\_m} and \lean{ex\_info} types.

Since the tactic works bottom up,
constructing normal forms by applying each operator to the normal form of its operands,
after each operation the subproofs can be discarded.
Each \lean{ex} value carries its proof of normalisation,
but as soon as an operation, such as adding two expressions $a$ and $b$, has finished,
the normalisation proofs of $a$ and $b$ are no longer needed and are deleted.
Similarly, any proof that reduces to reflexivity is deleted.
This results in smaller proof terms, reducing memory usage and type checking time.
%The final benefit is for debugging: the representation of \lean{ex} is simpler.

%Another test involved replacing all calls to \ring with \ringexp in the compilation of \mathlib.
%The compilation time in both cases was approximately the same:

The result of these optimisations can be quantified by comparing the running time of \ring and \ringexp on randomly generated expressions.%
\footnote{The benchmark program and an analysis script is available at \url{https://github.com/lean-forward/ring_exp}.}
The performance measure is the tactic execution time reported by the Lean profiler,
running on a 3 GHz Intel\textregistered\xspace Core\texttrademark\xspace i5-8500 CPU with 16 GB of RAM.
On arbitrary expressions, the benchmark indicates that \ringexp is a constant factor of approximately $3.88$ times slower than \ring;
on linear expressions such as passed by \lean{linarith}, 
\ringexp is $1.67$ times slower than \ring.
% The benchmark also serves as a correctness test for \ringexp, checking that arbitrary expressions are correctly handled.

%Apart from checking running time, these tests served to verify that \ringexp can parse arbitrary expressions.
% During development, \mathlib was compiled with all calls to \ring replaced with \ringexp.
% This ensured that \ringexp serves as a drop-in replacement for \ring.
% with ring: lean --make src/all.lean  3444.96s user 6.63s system 556% cpu 10:19.94 total
% 

%\begin{figure}
%\input{linexpr.tex}
%\caption{Running time of \ring and \ringexp on linear expressions.}
%\end{figure}
%\begin{figure}
%\input{expr-small.tex}
%\caption{Running time of \ring and \ringexp on arbitrary expressions.}
%\end{figure}

%\begin{figure}
%\centering
%\subfloat[Running time of \ring and \ringexp on linear expressions.]{\resizebox{0.3\textwidth}{!}{\input{linexpr.tex}}} \hspace{0.05\textwidth}
%\subfloat[Running time of \ring and \ringexp on arbitrary expressions.]{\resizebox{0.3\textwidth}{!}{\input{expr-large.tex}}} \hspace{0.05\textwidth}
%\subfloat[Running time of \ring and \ringexp on arbitrary expressions (detail).]{\resizebox{0.3\textwidth}{!}{\input{expr-small.tex}}}
%\end{figure}

\section{Discussion}

The \ring tactic for Coq and Lean can efficiently convert expressions in the language of semirings to normal form.
%HOL Light has the normalising procedure \texttt{SEMIRING\_NORMALIZERS\_CONV} for expressions in $+$ and $*$ (which also supports exponentiation with a constant exponent), analogous to \lean{ring}.
% This procedure powers \texttt{NUM\_NORMALIZE\_CONV} and \texttt{REAL\_POLY\_CONV}.
A normalizing procedure for polynomials is also included with HOL Light~\cite{hol_light} and Isabelle/HOL~\cite{isabelle_hol},
and decision procedures exist that support exponential functions~\cite{resolution-rcf};
none of these allows compound expressions in exponents.
% \cite{coq-assoc-comm} is acrefl for coq, \cite{coq-lattices} uses a decision procedure without normalisation.
% Term rewriting systems support compound exponents by adding the relevant equations,
% but typically lack support for numerals.

Compared with the \ring tactic, the \ringexp tactic can deal with a strict superset of expressions,
and can do so without sacrificing too much speed.
The extensible nature of the \ex type should make it simple to add support for more operators to \ringexp.
% including those not arising from algebra, such as casts~\cite{norm-cast}.
Independently, it should be possible to adapt the \ex type to other algebraic structures
such as lattices or vector spaces.
Although more optimisations are needed to fully equal \ring in efficiency,
the \ringexp tactic already achieves its goal of being a more general normalisation tactic.
These results are as much a consequence of engineering effort as of theoretical work.

%An interesting question is whether it is possible to automatically derive an appropriate \ex type
%and its operations, given a set of distributivity, associativity and commutativity relations.

\paragraph{Acknowledgements}
The author has received funding from the NWO under the Vidi program (project
No. 016.Vidi.189.037, Lean Forward).

Floris van Doorn, Mario Carneiro and Robert Y. Lewis reviewed the code and
suggested improvements.
Jasmin Blanchette and Robert Y. Lewis read this paper and gave useful suggestions.
Many thanks for the help!
% Readers: Jasmin Blanchette, Robert Y. Lewis, ...

\printbibliography
\end{document}
