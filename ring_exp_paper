A tactic for normalising ring expressions with exponents
========================================================

Abstract:
This paper describes the design of the normalising tactic `ring_exp` for the Lean prover.
This tactic improves on existing tactics by adding a binary exponent operator to the language of rings.
A normal form is represented with an inductive family of types, enforcing various invariants.
The design can also be extended with more operators.

Introduction
------------

We can use a normalising tactic to prove equalities.
Examples in mathlib: `norm_cast`, `norm_num`, `ring`, `simp`, ...

The Lean mathematical library already had a tactic `ring` for commutative rings.
The `ring` tactic is useful: occurs $N$ times in the mathlib code base.
Can also be used as components of other tactics: `linarith`, `omega`, ...

Horner normal forms cannot represent compound exponents.

Exponents also result in heterogeneous expressions: $a^b$ has $a : α$ for any ring, but $b : ℕ$.

The goal was to make a tactic whose domain is a strict superset of `ring`'s.
This was possible without sacrificing the efficiency of `ring`.
An additional result is that the design is extensible to more operators.

Overview of the tactic
----------------------

Similar scheme as `ring`:
expression -eval-> `ex` -simple-> expression
We want that `simple (eval x) = x` and `eval x = eval y` iff `x = y` (where `=` stands for propositional equality)

The full set of operators supported by the tactic consists of $+$, $*$ and $^$,
and if they are defined on the ring also $-$ and $/$.
Compound expressions consist of these operators applied to other compound expressions, rational numerals or atoms.
	[They should not be confused with those of an `exponential ring', which is a ring $(R, +, *)$ equipped with a monoid homomorphism $E : (R, +) \to (R^*, *)$.]

Types for correctness:
The structure of `ex` is interesting here:
 - indexed family of types for associativity and distributivity
 - use matrix of equalities to determine constructor parameters
ideally use types to enforce commutativity, but equality of expressions is not expressible

Some examples on how the equalities are reflected in the types.

Some examples where the types are incomplete, and how the tactic mitigates that. 

The `ex_info` type allows us to (re)construct the proof that normalisation is correct.
For each operation, instantiate correctness proof (properties are subtle to express) and combine these while evaluating.

Interpreting operators:
Define $+$, $*$ and $^$ for `ex t` for each `t` and interpret expressions using these.

The setup makes it easy to extend `ex` with another operator by adding a new constructor.

Complications
-------------

Dealing with atoms (expressions not parsed by `ring_exp`):
keep a list of all unique (modulo definitional equality) atoms encountered, compare on index into list (not structure of atom!).

Commutativity: commutative operators sort arguments by picking an order on `ex`.
Order should be consistent (Lean's expr.has_lt is not): order atoms by appearance, the rest lexicographically.

Dealing with $a ^ b$: interpret $b$ as a natural number (integer?):
use a reader monad to keep track of the expression's inferred type.

Dealing with numerals: don't unfold `2 * a` to `a + a`, but fold `1 * a + 1 * a` to `2 * a`.
But when adding, the tactic needs to keep track of overlap.

Dealing with $a - b$: rewrite to $a + (-1) * b$.
Dealing with $a / b$: rewrite to $a * b^(-1)$.

Normalising atoms as well: use `ring_exp` as a component of the `simp` framework.

Optimisations
-------------

An important reason to prefer `ring_exp` over `simp` is that `ring_exp` should be faster.
It will be called often as part of various other tactics: `linarith`, ...

The `ring` tactic is successful, so it will be the reference point.

Optimisations:
Making the tactic fast enough took some work:
- The tactic precomputes typeclass instances because typeclass inference can be very expensive.
- The numerals `0` and `1` are also precomputed.
- Although the proofs can take implicit arguments, they are all made explicit.
- During construction of an `ex`, the correctness proof ``migrates outward'', saving memory by discarding the proofs in subexpressions.

Results of optimising:
Empirically, there is only a constant factor slowdown compared to `ring`:
1.6 times in the case of linear expressions (i.e. `linarith`).
Faster than `ring` for e.g. $(x + 1)^4 = (1 + x)^4$.

Some graphs with nice regression lines.

To test, replace the implementation of `ring` with `ring_exp` in mathlib: no errors, same compilation time.

Discussion
----------

The `ring_exp` tactic can deal with a strict superset of expressions,
and does so without sacrificing too much speed.

The approach should be adaptable to extra operators (gcd? min/max?) and similar problem domains (lattices? propositions?).
Can we automate the construction of the `ex` type? (Probably not?)
